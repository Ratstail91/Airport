import standard;
import node;
import random;

//variables
var gridPositionX: int = 1;
var gridPositionY: int = 1;

var direction: int = null; //BUGFIX: animation not looping properly

var stepAI: int = 0;

//polyfills - animating different cycles on one image
var walkAnimationCounter: int = 0;

fn faceDown(node: opaque) {
	if (direction == 0) return;
	direction = 0;
	node.setNodeRect(0, 0, 32, 32);
	node.setNodeFrames(2);
	walkAnimationCounter = 12;
}

fn faceUp(node: opaque) {
	if (direction == 1) return;
	direction = 1;
	node.setNodeRect(32 * 2, 0, 32, 32);
	node.setNodeFrames(2);
	walkAnimationCounter = 12;
}

fn faceRight(node: opaque) {
	if (direction == 2) return;
	direction = 2;
	node.setNodeRect(32 * 4, 0, 32, 32);
	node.setNodeFrames(2);
	walkAnimationCounter = 12;
}

fn faceLeft(node: opaque) {
	if (direction == 3) return;
	direction = 3;
	node.setNodeRect(32 * 6, 0, 32, 32);
	node.setNodeFrames(2);
	walkAnimationCounter = 12;
}


//accessors & mutators
fn setGridPosition(node: opaque, x: int, y: int) {
	gridPositionX = x;
	gridPositionY = y;

	node.setNodePositionX(floor( gridPositionX * node.getNodeRectW() / node.getNodeScaleX() ));
	node.setNodePositionY(floor( gridPositionY * node.getNodeRectH() / node.getNodeScaleY() ));
}

fn getGridPositionX(node: opaque) {
	return gridPositionX;
}

fn getGridPositionY(node: opaque) {
	return gridPositionY;
}


//lifecycle functions
fn onLoad(node: opaque) {
	node.loadNodeTexture("sprites:/drone.png");
	node.faceDown();
	
	node.setNodeScaleX(CAMERA_SCALE_X);
	node.setNodeScaleY(CAMERA_SCALE_Y);
}

fn onStep(node: opaque) {
	if (++walkAnimationCounter >= 12) {
		node.incrementCurrentNodeFrame();
		walkAnimationCounter = 0;
	}

	//move in realspace
	var distX = gridPositionX * TILE_PIXEL_WIDTH - node.getNodePositionX();
	var distY = gridPositionY * TILE_PIXEL_HEIGHT - node.getNodePositionY();

	node.setNodeMotionX( normalize(distX) );
	node.setNodeMotionY( normalize(distY) );
}

fn onFree(node: opaque) {
	node.freeNodeTexture();
}

fn onDraw(node: opaque) {
	var posX: int = node.getNodeWorldPositionX();
	var posY: int = node.getNodeWorldPositionY();

	var scaleX: float = node.getNodeWorldScaleX();
	var scaleY: float = node.getNodeWorldScaleY();

	//this offset is because the sprite cell for lejana is twice as big as the sprite cell for the floor tiles
	var originOffsetX: int = node.getNodeRectW() * int scaleX / 4;
	var originOffsetY: int = node.getNodeRectH() * int scaleY / 2;

	node.drawNode(
		floor(posX * scaleX) - originOffsetX,
		floor(posY * scaleY) - originOffsetY,
		floor(node.getNodeRectW() * scaleX),
		floor(node.getNodeRectH() * scaleY)
	);
}

//gameplay functions
fn runAI(node: opaque, rng: opaque) {
	if (stepAI++ >= 1) {
		stepAI = 0;

		var dir = rng.generateRandomNumber() % 4;
		var moveX = 0;
		var moveY = 0;

		if (dir == 0) {
			moveY += 1;
			node.faceDown();
		}

		if (dir == 1) {
			moveY -= 1;
			node.faceUp();
		}

		if (dir == 2) {
			moveX += 1;
			node.faceRight();
		}

		if (dir == 3) {
			moveX -= 1;
			node.faceLeft();
		}

		if (node.getParentNode().callNodeFn("getWalkableAt", gridPositionX + moveX, gridPositionY + moveY)) {
			gridPositionX += moveX;
			gridPositionY += moveY;
		}
	}
}


//polyfills - move these to standard
fn normalize(x): int {
	if (x > 0) {
		return 1;
	}
	if (x < 0) {
		return -1;
	}
	return 0;
}