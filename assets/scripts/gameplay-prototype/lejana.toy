import standard;
import node;

var gridPositionX: int = 1; //position on the game grid
var gridPositionY: int = 1;

var inputX: int = 0; //cache the keyboard input
var inputY: int = 0;

var direction: int = null; //BUGFIX: animation not looping properly
var enableMovementCounter: int = 60 * 3; //BUGFIX: freeze while drones reach their starting spot

//polyfills - animating different cycles on one image 
var walkAnimationCounter: int = 0;
var attackAnimationCounter: int = 0;

//utils for facing different directions (idling)
fn faceDown(node: opaque) {
	if (direction == 0) return;
	direction = 0;
	node.setNodeRect(0, 0, 32, 32);
	node.setNodeFrames(4);
	walkAnimationCounter = 12;
}

fn faceUp(node: opaque) {
	if (direction == 1) return;
	direction = 1;
	node.setNodeRect(32 * 4, 0, 32, 32);
	node.setNodeFrames(4);
	walkAnimationCounter = 12;
}

fn faceRight(node: opaque) {
	if (direction == 2) return;
	direction = 2;
	node.setNodeRect(32 * 8, 0, 32, 32);
	node.setNodeFrames(4);
	walkAnimationCounter = 12;
}

fn faceLeft(node: opaque) {
	if (direction == 3) return;
	direction = 3;
	node.setNodeRect(32 * 12, 0, 32, 32);
	node.setNodeFrames(4);
	walkAnimationCounter = 12;
}

//accessors & mutators
fn setGridPosition(node: opaque, x: int, y: int) {
	gridPositionX = x;
	gridPositionY = y;

	node.setNodePositionX(floor( gridPositionX * node.getNodeRectW() / node.getNodeScaleX() ));
	node.setNodePositionY(floor( gridPositionY * node.getNodeRectH() / node.getNodeScaleY() ));
}

fn getGridPositionX(node: opaque) {
	return gridPositionX;
}

fn getGridPositionY(node: opaque) {
	return gridPositionY;
}

//lifecycle functions
fn onLoad(node: opaque) {
	node.loadNodeTexture("sprites:/lejana.png"); //NOTE: all of this script is mapped to this sprite sheet
	node.faceDown();

	node.setNodeScaleX(CAMERA_SCALE_X);
	node.setNodeScaleY(CAMERA_SCALE_Y);
}

//fn onUpdate(node: opaque, delta: int) {
//	//
//}

fn onStep(node: opaque) {
	//initial freeze
	if (enableMovementCounter > 0) {
		enableMovementCounter--;
		return;
	}

	//animation - start idling
	if (attackAnimationCounter == 0) {
		//move to standing state
		if (node.getNodeRectY() != 0) {
			node.setNodeRect(direction * 32 * 4, 0, 32, 32);
			node.setNodeFrames(4);
			walkAnimationCounter = 12;
		}
	}

	//animation - start attacking
	if (--attackAnimationCounter >= 0) {
		//move to attacking state
		if (node.getNodeRectY() != 32) {
			node.setNodeRect(direction * 32 * 4, 32, 32, 32);
			node.setNodeFrames(3);
		}

		if ((attackAnimationCounter+1) % 4 == 0) { //+1 for a bugfix
			node.incrementCurrentNodeFrame();
		}

		//skip out
		return;
	}

	//facing
	if (inputY > 0) {
		node.faceDown();
	}

	else if (inputY < 0) {
		node.faceUp();
	}

	else if (inputX > 0) {
		node.faceRight();
	}

	else if (inputX < 0) {
		node.faceLeft();
	}

	//BUGFIX for smooth animation fo
	var lesser = 0;
	if ((inputX != 0 || inputY != 0) && attackAnimationCounter == 0) {
		lesser = 6;
	}

	//actually animate
	if (--walkAnimationCounter <= lesser) {
		node.incrementCurrentNodeFrame();
		walkAnimationCounter = 12;
	}

	var parent = node.getParentNode(); //check for collisions from the parent

	if (parent.callNodeFn("getWalkableAt", gridPositionX + inputX, gridPositionY + inputY) && abs(inputX) != abs(inputY)) {
		//calc movement
		gridPositionX += inputX;
		gridPositionY += inputY;

		parent.callNodeFn("runAI");
	}

	//move in realspace
	var distX = gridPositionX * TILE_PIXEL_WIDTH - node.getNodePositionX();
	var distY = gridPositionY * TILE_PIXEL_HEIGHT - node.getNodePositionY();

	node.setNodeMotionX( normalize(distX) );
	node.setNodeMotionY( normalize(distY) );

	//reset input
	inputX = 0;
	inputY = 0;
}

fn onFree(node: opaque) {
	node.freeNodeTexture();
}

fn onDraw(node: opaque) {
	var posX: int = node.getNodeWorldPositionX();
	var posY: int = node.getNodeWorldPositionY();

	var scaleX: float = node.getNodeWorldScaleX();
	var scaleY: float = node.getNodeWorldScaleY();

	//this offset is because the sprite cell for lejana is twice as big as the sprite cell for the floor tiles
	var originOffsetX: int = player.getNodeRectW() / 2;
	var originOffsetY: int = player.getNodeRectH();

	node.drawNode(
		floor(posX * scaleX) - originOffsetX + globalCameraX,
		floor(posY * scaleY) - originOffsetY + globalCameraY,
		floor(node.getNodeRectW() * scaleX),
		floor(node.getNodeRectH() * scaleY)
	);
}


//event functions
fn onKeyDown(node: opaque, event: string) {
	//initial freeze
	if (enableMovementCounter > 0) {
		return;
	}

	//enable attack
	if (event == "character_attack" && inputX == 0 && inputY == 0) {
		attackAnimationCounter = 12;
		return;
	}

	//if moving, don't take any more input
	if (node.getNodeMotionX() != 0 || node.getNodeMotionY() != 0) {
		return;
	}

	if (event == "character_up") {
		inputY -= 1;
		return;
	}

	if (event == "character_down") {
		inputY += 1;
		return;
	}

	if (event == "character_left") {
		inputX -= 1;
		return;
	}

	if (event == "character_right") {
		inputX += 1;
		return;
	}
}

fn onKeyUp(node: opaque, event: string) {
	if (event == "character_up" && inputY < 0) {
		inputY = 0;
		return;
	}

	if (event == "character_down" && inputY > 0) {
		inputY = 0;
		return;
	}

	if (event == "character_left" && inputX < 0) {
		inputX = 0;
		return;
	}

	if (event == "character_right" && inputX > 0) {
		inputX = 0;
		return;
	}
}

//polyfills - move these to standard
fn normalize(x): int {
	if (x > 0) {
		return 1;
	}
	if (x < 0) {
		return -1;
	}
	return 0;
}