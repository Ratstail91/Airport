import standard;
import engine;
import node;


//constants for generating maps
var TILE_PIXEL_WIDTH: int const = 16;
var TILE_PIXEL_HEIGHT: int const = 16;

var ROOM_MIN_WIDTH: int const = 4; //minimum safe value 4
var ROOM_MIN_HEIGHT: int const = 4;

var ROOM_MAX_WIDTH: int const = 12;
var ROOM_MAX_HEIGHT: int const = 12;

var CELL_WIDTH: int const = 16; //minimum safe value ROOM_MAX_* + 4
var CELL_HEIGHT: int const = 16;

var CELL_COUNT_X: int const = 3;
var CELL_COUNT_Y: int const = 3;

var MAP_GRID_WIDTH: int const = CELL_WIDTH * CELL_COUNT_X;
var MAP_GRID_HEIGHT: int const = CELL_HEIGHT * CELL_COUNT_Y;


//lifecycle functions
fn onLoad(node: opaque) {
	//load the atlas into this node
	node.loadNodeTexture("sprites:/tileset.png");

	//create a child as a render target
	var child: opaque = node.loadChildNode("scripts:/tilemap/renderer-child.toy");
	child.createNodeTexture(MAP_GRID_WIDTH * TILE_PIXEL_WIDTH, MAP_GRID_HEIGHT * TILE_PIXEL_HEIGHT);
}

//TODO: lazily render
fn setTilemap(node: opaque, tilemap: [int]) {
	assert tilemap, "provided tilemap is null (in setTilemap)";

	var child: opaque = node.getChildNode(0);
	setRenderTarget(child);

	//draw the tilemap to the child
	for (var j = 0; j < MAP_GRID_HEIGHT; j++) {
		for (var i = 0; i < MAP_GRID_WIDTH; i++) {
			//don't recalculate this every time
			var ITERATION: int const = j * MAP_GRID_WIDTH * 3 + i * 3;

			//don't render empty tiles
			if (tilemap[ITERATION] < 0 || tilemap[ITERATION + 1] < 0) {
				continue;
			}

			//set the rect of the node on the tilesheet - the "tilemap" var is a single blob of data
			node.setNodeRect(
				tilemap[ITERATION]     * TILE_PIXEL_WIDTH,
				tilemap[ITERATION + 1] * TILE_PIXEL_HEIGHT,
				TILE_PIXEL_WIDTH, TILE_PIXEL_HEIGHT
			);

			//draw to the screen
			node.drawNode(
				(i * TILE_PIXEL_WIDTH),
				(j * TILE_PIXEL_HEIGHT),
				TILE_PIXEL_WIDTH,
				TILE_PIXEL_HEIGHT
			);
		}
	}

	//reset the render target to the screen
	setRenderTarget(null);
}
