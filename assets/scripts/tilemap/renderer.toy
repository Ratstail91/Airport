import standard;
import engine;
import node;


//constants for generating maps
var TILE_PIXEL_WIDTH: int const = 16;
var TILE_PIXEL_HEIGHT: int const = 16;

var ROOM_MIN_WIDTH: int const = 4; //minimum safe value 4
var ROOM_MIN_HEIGHT: int const = 4;

var ROOM_MAX_WIDTH: int const = 12;
var ROOM_MAX_HEIGHT: int const = 12;

var CELL_WIDTH: int const = 16; //minimum safe value ROOM_MAX_* + 4
var CELL_HEIGHT: int const = 16;

var CELL_COUNT_X: int const = 3;
var CELL_COUNT_Y: int const = 3;


var tilemap: [int] = null;

//lifecycle functions
fn onLoad(node: opaque) {
	//load the atlas into this node
	node.loadNodeTexture("sprites:/tileset.png");
}

fn setTilemap(node: opaque, t: [int]) {
	assert t, "provided tilemap is null (in setTilemap)";

	tilemap = t;

	//create a child as a render target
	var child = node.loadChildNode("scripts:/tilemap/renderer-child.toy");
	child.createNodeTexture(CELL_WIDTH * CELL_COUNT_X * TILE_PIXEL_WIDTH, CELL_HEIGHT * CELL_COUNT_Y * TILE_PIXEL_HEIGHT);
	setRenderTarget(child);

	//draw the tilemap to the child
	for (var j = 0; j < CELL_HEIGHT * CELL_COUNT_Y; j++) {
		for (var i = 0; i < CELL_WIDTH * CELL_COUNT_X; i++) {
			//don't render empty tiles
			if (tilemap[j * CELL_WIDTH * CELL_COUNT_X * 3 + i * 3] < 0) {
				continue;
			}

			//set the rect of the node on the tilesheet - the "tilemap" var is a single blob of data
			node.setNodeRect(
				tilemap[j * CELL_WIDTH * CELL_COUNT_X * 3 + i * 3]     * TILE_PIXEL_WIDTH,
				tilemap[j * CELL_WIDTH * CELL_COUNT_X * 3 + i * 3 + 1] * TILE_PIXEL_HEIGHT,
				TILE_PIXEL_WIDTH, TILE_PIXEL_HEIGHT
			);

			//draw to the screen
			node.drawNode(
				(i * TILE_PIXEL_WIDTH),
				(j * TILE_PIXEL_HEIGHT),
				TILE_PIXEL_WIDTH,
				TILE_PIXEL_HEIGHT
			);
		}
	}

	//reset the render target to the screen
	setRenderTarget(null);
}
