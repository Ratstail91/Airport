//this is one layer
import standard;
import engine;
import node;


//TODO: replace with an empty node function (polyfill)
fn loadChildEmpty(parent: opaque) {
	var child: opaque = loadNode("scripts:/empty.toy");
	parent.pushNode(child);
	return child;
}


fn onLoad(node: opaque) {
	//load the child node, with the tiling back image
	node.loadChildEmpty();
}

fn onInit(node: opaque) {
	node.getChildNode(0).loadTexture("sprites:/tile-background.png");
}


//drawing util
fn drawLayer(node: opaque, camX, camY, camW, camH, depth) {
	//get the constants from root
	var root: opaque = getRootNode();

	var tileWidth: int const = root.callNodeFn("getTileWidth");
	var tileHeight: int const = root.callNodeFn("getTileHeight");

	var roomWidth: int const = root.callNodeFn("getRoomWidth");
	var roomHeight: int const = root.callNodeFn("getRoomHeight");

	var levelXCount: int const = root.callNodeFn("getLevelXCount");
	var levelYCount: int const = root.callNodeFn("getLevelYCount");

	//calc the modifier ratio to offset things
	var mod: float = float tileWidth / (tileWidth - depth);

	var tileWidth_mod: float = tileWidth * mod;
	var tileHeight_mod: float = tileHeight * mod;
	var camX_mod: float = (camX - camW) * mod + camW/2;
	var camY_mod: float = (camY - camH) * mod + camH/2;

	//calc the region to render
	var lowerX: int = round((camX - camW/2.0) / tileWidth);
	var upperX: int = round((camX - camW*1.5) / tileWidth);
	var lowerY: int = round((camY - camH/2.0) / tileHeight);
	var upperY: int = round((camY - camH*1.5) / tileHeight);

	//bounds check
	lowerX = max(0, abs(lowerX));
	upperX = min(upperX < 0 ? abs(upperX) : 0, levelXCount * roomWidth);
	lowerY = max(0, abs(lowerY));
	upperY = min(upperY < 0 ? abs(upperY) : 0, levelYCount * roomHeight);

	//render each tile
	for (var j = lowerY; j <= upperY; j++) {
		for (var i = lowerX; i <= upperX; i++) {
			node.getChildNode(0).drawNode(round(camX_mod + i * tileWidth_mod), round(camY_mod + j * tileHeight_mod), round(tileWidth_mod), round(tileHeight_mod));
		}
	}
}
