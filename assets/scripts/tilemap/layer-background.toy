//this is one layer
import standard;
import node;

var childCounter: int = 0;

//TODO: reference these from a global source (root?)
var tileWidth: float const = 100;
var tileHeight: float const = 100;

var roomWidth: float const = 10;
var roomHeight: float const = 10;

var levelXCount: int const = 4;
var levelYCount: int const = 4;


//util to generate and init a child node of a given parent
fn makeChildSprite(parent: opaque, spriteName: string) {
	var child: opaque = loadNode("scripts:/tilemap/tile.toy");
	parent.pushNode(child);
	child.initNode();

	child.loadTexture("sprites:/" + spriteName);

	//BUGFIX
	childCounter++;

	return child;
}


fn onInit(node: opaque) {
	//load the child node, with the tiling back image
	node.makeChildSprite("tile-background.png");
}


fn drawLayer(node: opaque, camX, camY, camW, camH, depth) {
	//calc the modifier ratio to offset things
	var mod: float = float tileWidth / (tileWidth - depth);
	
	var tileWidth_mod = round(tileWidth * mod);
	var tileHeight_mod = round(tileHeight * mod);
	var camX_mod = (camX - camW) * mod + camW / 2;
	var camY_mod = (camY - camH) * mod + camH / 2;

	//calc the region to render
	var lowerX = round((camX - camW/2) / tileWidth);
	var upperX = round((camX - camW*1.5) / tileWidth);
	var lowerY = round((camY - camH/2) / tileHeight);
	var upperY = round((camY - camH*1.5) / tileHeight);

	//bounds check
	lowerX = max(0, abs(lowerX));
	upperX = min(upperX < 0 ? abs(upperX) : 0, levelXCount * roomWidth);
	lowerY = max(0, abs(lowerY));
	upperY = min(upperY < 0 ? abs(upperY) : 0, levelYCount * roomHeight);

	//render each tile
	for (var j = lowerY; j <= upperY; j++) {
		for (var i = lowerX; i <= upperX; i++) {
			node.getNodeChild(0).drawNode(round(camX_mod + i * tileWidth_mod), round(camY_mod + j * tileHeight_mod), tileWidth_mod, tileHeight_mod);
		}
	}
}

//math utils
fn round(x): int {
	var f = floor(x);
	return x - f >= 0.5 ? f + 1 : f;
}

fn floor(x): int {
	return int x;
}

fn ceil(x): int {
	var f = floor(x);
	return x - f != 0 ? f + 1 : f;
}

fn min(a, b) {
	return a < b ? a : b;
}

fn max(a, b) {
	return a > b ? a : b;
}